export default class LevelValidator{
  validateConfig(level,boxCount,capacity,maxPerType=3){if(!level.types?.length)return{ok:false,message:'Плохой уровень: нет типов',fix:'Добавь types в конфиг.'};if(!level.triples||level.triples<1)return{ok:false,message:'Плохой уровень: triples < 1',fix:'Увеличь triples.'};if(!level.seconds||level.seconds<10)return{ok:false,message:'Плохой уровень: seconds слишком мало',fix:'Увеличь seconds.'};const min=Math.max(1,Math.min(capacity,level.fillMin||1));const max=Math.max(min,Math.min(capacity,level.fillMax||capacity-1));if(min>max)return{ok:false,message:'Плохой уровень: fillMin > fillMax',fix:'Проверь fillMin/fillMax.'};if(level.types.length*maxPerType<boxCount*min)return{ok:false,message:'Плохой уровень: мало типов для fillMin',fix:'Уменьши fillMin или добавь types.'};return{ok:true};}
  validateState(level,snapshot,planQueue,maxPerType=3){const boardCounts=new Map();snapshot.forEach((box)=>box.types.forEach((t)=>boardCounts.set(t,(boardCounts.get(t)||0)+1)));for(const [type,count] of boardCounts){if(count>maxPerType)return{ok:false,message:'Плохой уровень: превышен лимит на тип',fix:'Уменьши fillMax или types.'};}const canMove=this.#hasStartMove(snapshot,boardCounts);if(!canMove)return{ok:false,message:'Плохой уровень: нет стартовых ходов',fix:'Увеличь fillMax или добавь types.'};const remainingCounts=new Map();(planQueue||[]).forEach((t)=>remainingCounts.set(t,(remainingCounts.get(t)||0)+1));const allTypes=new Set([...boardCounts.keys(),...remainingCounts.keys()]);for(const type of allTypes){const total=(boardCounts.get(type)||0)+(remainingCounts.get(type)||0);if(total>0&&total<3)return{ok:false,message:'Плохой уровень: есть одиночные предметы',fix:'Увеличь triples или убери тип из types.'};}return{ok:true};}
  #hasStartMove(snapshot,counts){for(const box of snapshot){if(box.free<=0)continue;for(const t of box.types){if((counts.get(t)||0)>box.counts.get(t))return true;}}return false;}
}
